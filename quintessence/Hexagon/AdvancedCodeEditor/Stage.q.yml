parent_classes:


  - class: 'StageInterface'
    scope: public
    init_with: "StageInterface::ADVANCED_CODE_EDITOR"


properties:


  - name: font_bin
    type: AllegroFlare::FontBin*
    init_with: nullptr
    constructor_arg: true

  - name: num_columns
    type: int
    init_with: 0
    getter: true
    setter: false
    constructor_arg: true

  - name: num_rows
    type: int
    init_with: 0
    getter: true
    setter: false
    constructor_arg: true

  - name: text_mesh
    type: Hexagon::Elements::TextMesh
    init_with: '{nullptr, num_columns, num_rows}'

  - name: filename
    type: std::string
    init_with: '"untitled.txt"'
    getter: true
    setter: true

  - name: represents_symlink
    type: bool
    init_with: false
    getter: true
    setter: true

  - name: advanced_code_editor
    type: Hexagon::AdvancedCodeEditor::AdvancedCodeEditor
    init_with: '{}'
    getter_ref: true

  - name: input_buffer
    type: std::string
    init_with: '""'
    getter: true
    getter_ref: true
    setter: true

  - name: mode
    type: int
    init_with: 0

  - name: a_default_empty_event
    static: true
    type: ALLEGRO_EVENT
    init_with: "{}"
    getter_ref: true

  - name: initialized
    type: bool
    init_with: false
    getter: true

  - name: offset_y
    type: float
    init_with: 0.0f
    getter: true

  - name: offset_y_updated_at
    type: float
    init_with: 0.0f
    getter: true

  - name: first_row_offset
    type: int
    init_with: 0
    getter: true

  - name: surface_render
    type: ALLEGRO_BITMAP*
    init_with: nullptr
    getter: true

  - name: current_search_regex
    type: std::string
    init_with: '""'
    setter: true

  - name: code_message_point_manager
    type: Hexagon::CodeMessagePointManager
    init_with: '{}'

  - name: visual_selections
    type: std::vector<CodeRange>
    init_with: '{}'

  - name: currently_grabbing_visual_selection
    type: bool
    init_with: false
  
  - name: full_line_visual_selections
    type: std::vector<CodeRange>
    init_with: '{}'

  - name: currently_grabbing_full_line_visual_selection
    type: bool
    init_with: false
  
  - name: selections
    type: std::vector<Hexagon::AdvancedCodeEditor::Selection>
    init_with: '{}'

  - name: search_regex_selections
    type: Hexagon::AdvancedCodeEditor::Selection
    init_with: 'Hexagon::AdvancedCodeEditor::Selection{}'
    getter_ref: true

  - name: action_queue_recording
    type: ActionQueueRecording
    init_with: '{}'

  - name: currently_playing_action_queue_recording
    type: bool
    init_with: false
    getter: true

  - name: syntax_highlight_color
    type: ALLEGRO_COLOR
    init_with: ALLEGRO_COLOR{0.75f, 0.96f, 1.0f, 1.0f}
    getter: true
    setter: true

  - name: on_color
    type: ALLEGRO_COLOR
    init_with: ALLEGRO_COLOR{1.0f, 1.0f, 0.0f, 1.0f}
    getter: true
    setter: true

  - name: comment_color
    type: ALLEGRO_COLOR
    init_with: ALLEGRO_COLOR{0.5f, 0.5f, 0.5f, 0.5f}
    getter: true
    setter: true
   
  - name: clear_color
    type: ALLEGRO_COLOR
    init_with: ALLEGRO_COLOR{0.0f, 0.0f, 0.0f, 0.0f}
    getter: true
    setter: true

  - name: show_line_too_long
    type: bool
    init_with: false
    getter: true
    setter: true

  - name: max_line_length
    type: int
    init_with: 120
    getter: true
    setter: true

  - name: null_space_color
    type: ALLEGRO_COLOR
    init_with: ALLEGRO_COLOR{0.0f, 0.0f, 0.0f, 0.3f}
    getter: true
    setter: true

  - name: backfill_color
    type: ALLEGRO_COLOR
    init_with: ALLEGRO_COLOR{0.06, 0.06, 0.06, 0.06}
    getter: true
    setter: true

  - name: MODE_EDIT
    type: uint32_t
    init_with: 0
    static: true
    const: true
    constexpr: true

  - name: MODE_INSERT
    type: uint32_t
    init_with: 1
    static: true
    const: true
    constexpr: true

  - name: ACTION_SET_TO_EDIT_MODE
    type: char*
    init_with: '(char*)"set_to_edit_mode"'
    static: true
    const: true
    constexpr: true

  - name: ACTION_SET_TO_INSERT_MODE
    type: char*
    init_with: '(char*)"set_to_insert_mode"'
    static: true
    const: true
    constexpr: true


functions:


  - name: initialize
    guards: [ al_is_system_installed(), font_bin ]
    body: |
      if (initialized) return;

      text_mesh.set_font(obtain_text_font());
      text_mesh.initialize();

      initialize_surface_render();

      advanced_code_editor.cursor_set_width(text_mesh.get_cell_width());
      advanced_code_editor.cursor_set_height(text_mesh.get_cell_height());

      get_place().size = vec3d(
         calculate_natural_width(),
         calculate_natural_height(),
         0
      );

      initialized = true;
      return;


  - name: initialize_surface_render
    private: true
    body: |
      ALLEGRO_STATE previous_render_state;
      al_store_state(&previous_render_state, ALLEGRO_STATE_TARGET_BITMAP);
      // TODO: may choose to add some bitmap flags
      surface_render = al_create_bitmap(
         calculate_natural_width(),
         calculate_natural_height()
      );
      al_set_target_bitmap(surface_render);
      al_clear_to_color(clear_color);
      al_restore_state(&previous_render_state);
      return;


  - name: destroy
    virtual: true
    override: true
    body: |
      if (surface_render) al_destroy_bitmap(surface_render);
      initialized = false;
      return;


  - name: refresh_search_regex_selections
    type: bool
    body: |
      if (current_search_regex.empty())
      {
         search_regex_selections.clear();
      }
      else
      {
         Hexagon::AdvancedCodeEditor::SearchRegexToSelectionsConverter converter(
            current_search_regex, get_lines());
         search_regex_selections = converter.convert();
      }
      return true;
    body_dependency_symbols:
      - Hexagon::AdvancedCodeEditor::SearchRegexToSelectionsConverter   


  - name: refresh_search_regex_selections_on_select_lines
    type: bool
    parameters:
      - name: line_nums
        type: std::vector<int>
        default_argument: '{}'
    body: |
      // HERE
      // 1) clear selections on select lines
      search_regex_selections.clear_select_lines(line_nums);

      if (current_search_regex.empty()) return true;

      // 2) get select lines
      std::map<int, std::string> select_lines = advanced_code_editor.get_select_lines(line_nums);

      // 3) run SearchRegexToSelectionsConverter on these lines (TODO)
      Hexagon::AdvancedCodeEditor::SearchRegexToSelectionsConverter converter(current_search_regex);
      
      std::vector<CodeRange> result_ranges;
      for (auto &select_line : select_lines)
      {
         Hexagon::AdvancedCodeEditor::SearchRegexToSelectionsConverter converter(
            current_search_regex, std::vector<std::string>({ select_line.second })
         );
         std::vector<CodeRange> created_ranges = converter.convert();

         // 3.1) convert the result selections to their expected line nums
         for (auto &regex_selection : created_ranges)
         {
            int this_line_num = select_line.first;
            regex_selection.move(0, this_line_num);

            // 3.2) insert the selections into the existing search_regex_selections
            search_regex_selections.add(regex_selection);
         }
      }

      return true;
    body_dependency_symbols:
      - Hexagon::AdvancedCodeEditor::SearchRegexToSelectionsConverter   


  - name: set_code_message_points
    parameters:
      - name: code_message_points
        type: std::vector<CodeMessagePoint>
        default_argument: '{}'
    body: |
      code_message_point_manager.set_code_message_points(code_message_points);
      return;


  - name: save_file
    type: bool
    body: |
      std::vector<std::string> &lines = advanced_code_editor.get_lines_ref();
      ::save_file(lines, filename);
      advanced_code_editor.unmark_content_is_modified();
      return true;
    body_dependency_symbols:
      - ::save_file


  - name: save_file_and_touch_if_symlink
    type: bool
    body: |
      std::vector<std::string> &lines = advanced_code_editor.get_lines_ref();
      Hexagon::SymlinkToucher symlink_toucher(filename); // this is only needed because of rerun

      ::save_file(lines, filename);
      symlink_toucher.touch_if_symlink();
      advanced_code_editor.unmark_content_is_modified();

      return true;
    body_dependency_symbols:
      - ::save_file
      - Hexagon::SymlinkToucher


  - name: set_to_edit_mode
    type: bool
    body: |
      mode = MODE_EDIT;
      return true;


  - name: set_to_insert_mode
    type: bool
    body: |
      mode = MODE_INSERT;
      if (currently_grabbing_visual_selection) toggle_currently_grabbing_visual_selection();
      if (currently_grabbing_full_line_visual_selection) toggle_currently_grabbing_full_line_visual_selection();
      return true;


  - name: cursor_move_up
    type: bool
    body: |
      bool result = advanced_code_editor.cursor_move_up();
      refresh_current_visual_selection_end_to_current_cursor_position();
      return result;


  - name: cursor_move_down
    type: bool
    body: |
      bool result = advanced_code_editor.cursor_move_down();
      refresh_current_visual_selection_end_to_current_cursor_position();
      return result;


  - name: cursor_move_left
    type: bool
    body: |
      bool result = advanced_code_editor.cursor_move_left();
      refresh_current_visual_selection_end_to_current_cursor_position();
      return result;


  - name: cursor_move_right
    type: bool
    body: |
      bool result = advanced_code_editor.cursor_move_right();
      refresh_current_visual_selection_end_to_current_cursor_position();
      return result;


  - name: cursor_move_to_start_of_line
    type: bool
    body: |
      bool result = advanced_code_editor.cursor_move_to_start_of_line();
      refresh_current_visual_selection_end_to_current_cursor_position();
      return result;


  - name: cursor_move_to_start_of_file
    type: bool
    body: |
      bool result = advanced_code_editor.cursor_move_to_start_of_file();
      refresh_current_visual_selection_end_to_current_cursor_position();
      return result;


  - name: cursor_move_to_first_non_whitespace_character
    type: bool
    body: |
      bool result = advanced_code_editor.cursor_move_to_first_non_whitespace_character();
      refresh_current_visual_selection_end_to_current_cursor_position();
      return result;


  - name: cursor_move_to_end_of_line
    type: bool
    body: |
      bool result = advanced_code_editor.cursor_move_to_end_of_line();
      refresh_current_visual_selection_end_to_current_cursor_position();
      return result;


  - name: cursor_jump_to_next_word
    type: bool
    body: |
      bool result = advanced_code_editor.cursor_jump_to_next_word();
      refresh_current_visual_selection_end_to_current_cursor_position();
      return result;


  - name: cursor_jump_to_next_word_or_last_char
    type: bool
    body: |
      bool result = advanced_code_editor.cursor_jump_to_next_word_or_last_char();
      refresh_current_visual_selection_end_to_current_cursor_position();
      return result;


  - name: cursor_jump_to_previous_word
    type: bool
    body: |
      bool result = advanced_code_editor.cursor_jump_to_previous_word();
      refresh_current_visual_selection_end_to_current_cursor_position();
      return result;


  - name: cursor_jump_up_half_page
    type: bool
    body: |
      // TODO: account for "surface_render"
      int new_y = advanced_code_editor.cursor_get_y() - num_rows / 2;
      if (new_y < 0) new_y = 0;
      bool result = advanced_code_editor.cursor_set_y(new_y); // TODO also only allow this behavior if will go out
                                                              // of bounds and not if already out of bounds going
                                                              // further out of bounds
      refresh_current_visual_selection_end_to_current_cursor_position();
      return result;


  - name: append_action_to_action_queue_recording
    parameters:
      - name: action_name
        type: std::string
        default_argument: '"[unset-action_name]"'
      - name: action_data1
        type: ActionData
        default_argument: '{}'
    body: |
      action_queue_recording.append_action(Action(action_name, action_data1));
      return;


  - name: clear_action_queue_recording
    body: |
      action_queue_recording.clear_actions();
      return;


  - name: cursor_jump_down_half_page
    type: bool
    body: |
      // TODO: account for "surface_render"
      int new_y = advanced_code_editor.cursor_get_y() + num_rows / 2;
      int num_lines = advanced_code_editor.get_lines_ref().size();
      if (new_y >= (num_lines - 1)) new_y = num_lines - 1; // TODO also only allow this behavior if will go out of
                                                           // bounds and not if already out of bounds going further
                                                           // out of bounds

      bool result = advanced_code_editor.cursor_set_y(new_y);
      refresh_current_visual_selection_end_to_current_cursor_position();
      return result;


  - name: first_row_offset_move_up
    type: bool
    body: |
      // TODO: account for "surface_render"
      first_row_offset -= 1;
      refresh_text_mesh_respecting_first_row_offset(); // <-- this can be optimized
      return true;


  - name: first_row_offset_move_down
    type: bool
    body: |
      // TODO: account for "surface_render"
      first_row_offset += 1;
      refresh_text_mesh_respecting_first_row_offset(); // <-- this can be optimized
      return true;


  - name: first_row_offset_jump_to
    parameters:
      - name: new_offset
        type: int
        default_argument: 0
    type: bool
    body: |
      // TODO: account for "surface_render"
      first_row_offset = new_offset;
      refresh_text_mesh_respecting_first_row_offset(); // <-- this can be optimized
      return true;


  - name: first_row_offset_jump_up_half_page
    type: bool
    body: |
      // TODO: account for "surface_render"
      first_row_offset = first_row_offset - calculate_half_num_rows();
      refresh_text_mesh_respecting_first_row_offset(); // <-- this can be optimized
      return true;


  - name: first_row_offset_jump_down_half_page
    type: bool
    body: |
      // TODO: account for "surface_render"
      first_row_offset = first_row_offset + calculate_half_num_rows();
      refresh_text_mesh_respecting_first_row_offset(); // <-- this can be optimized
      return true;


  - name: first_row_offset_adjust_so_cursor_is_vertically_centered
    type: bool
    body: |
      // TODO: account for "surface_render"
      first_row_offset = cursor_get_y() - calculate_one_third_num_rows();
      refresh_text_mesh_respecting_first_row_offset(); // <-- this can be optimized
      return true;


  - name: cursor_jump_to_next_code_message_point
    type: bool
    body: |
      return true;


  - name: cursor_jump_to_previous_code_message_point
    type: bool
    body: |
      return true;


  - name: cursor_jump_to_next_search_regex_selection
    type: bool
    body: |
      // TODO: account for "surface_render"
      CodePoint next_position = search_regex_selections.find_next_from(cursor_get_x(), cursor_get_y());
      cursor_move_to(next_position.get_x(), next_position.get_y());
      first_row_offset_jump_to(cursor_get_y() - 20); // TODO get a constant offset other than 20
      refresh_text_mesh_respecting_first_row_offset(); // <-- this can be optimized
      refresh_current_visual_selection_end_to_current_cursor_position();
      return true;


  - name: cursor_jump_to_previous_search_regex_selection
    type: bool
    body: |
      CodePoint previous_position = search_regex_selections.find_previous_from(cursor_get_x(), cursor_get_y());
      cursor_move_to(previous_position.get_x(), previous_position.get_y());
      first_row_offset_jump_to(cursor_get_y() - 20); // TODO get a constant offset other than 20
      refresh_text_mesh_respecting_first_row_offset(); // <-- this can be optimized
      refresh_current_visual_selection_end_to_current_cursor_position();
      return true;


  - name: delete_character
    type: bool
    guards: [ initialized ]
    body: |
      bool result = advanced_code_editor.delete_character();
      if (advanced_code_editor.any_dirty_cells()) refresh_render_surfaces();
      if (result) refresh_search_regex_selections_on_current_line();
      refresh_current_visual_selection_end_to_current_cursor_position(); // TODO: only do if result == true
      return result;


  - name: refresh_search_regex_selections_on_current_line
    type: bool
    private: true
    body: |
      return refresh_search_regex_selections_on_select_lines({cursor_get_y()});


  - name: grab_word_under_cursor
    type: std::string
    guards: [ initialized ]
    body: |
      if (cursor_get_y() < 0) return "";
      if (cursor_get_y() >= advanced_code_editor.get_lines_ref().size()) return "";

      // HERE
      // get word ranges
      std::string line_content = advanced_code_editor.get_lines_ref()[cursor_get_y()];
      Hexagon::WordRangesFinder word_ranges_finder(line_content, cursor_get_x());

      std::pair<int, int> found_word_ranges = word_ranges_finder.find_ranges();
      // if word ranges are invalid, return false
      if (!word_ranges_finder.is_valid(found_word_ranges)) return "";

      std::string word_under_cursor = line_content.substr(found_word_ranges.first, found_word_ranges.second);

      return word_under_cursor;


  - name: delete_word_under_cursor
    type: bool
    guards: [ initialized ]
    body: |
      if (cursor_get_y() < 0) return false;
      if (cursor_get_y() >= advanced_code_editor.get_lines_ref().size()) return false;

      // get word ranges
      std::string line_content = advanced_code_editor.get_lines_ref()[cursor_get_y()];
      Hexagon::WordRangesFinder word_ranges_finder(line_content, cursor_get_x());

      std::pair<int, int> found_word_ranges = word_ranges_finder.find_ranges();
      // if word ranges are invalid, return false
      if (!word_ranges_finder.is_valid(found_word_ranges)) return false;
      
      // move cursor to beginning of inside word
      cursor_move_to(found_word_ranges.first, cursor_get_y());

      // delete n characters, the length of the word
      // if any delete_character() returns false, set the result to false      
      bool result = true;
      int num_characters_to_delete = found_word_ranges.second;
      for (int i=0; i<num_characters_to_delete; i++)
      {
         bool this_deletion = advanced_code_editor.delete_character();
         if (!this_deletion) result = false;
      }
      
      if (advanced_code_editor.any_dirty_cells()) refresh_render_surfaces();
      refresh_current_visual_selection_end_to_current_cursor_position(); // TODO: consider on if result == true
      if (result) refresh_search_regex_selections_on_current_line();

      return result;
    body_dependency_symbols:
      - Hexagon::WordRangesFinder


  - name: delete_to_end_of_line
    type: bool
    body: |
      bool result = advanced_code_editor.delete_to_end_of_line();
      if (advanced_code_editor.any_dirty_cells()) refresh_render_surfaces();
      if (result) refresh_search_regex_selections_on_current_line();
      return result;


  - name: delete_to_next_word
    type: bool
    body: |
      bool result = advanced_code_editor.delete_to_next_word();
      if (advanced_code_editor.any_dirty_cells()) refresh_render_surfaces();
      if (result) refresh_search_regex_selections_on_current_line();
      return result;


  - name: delete_to_next_word_or_end_of_line
    type: bool
    body: |
      bool result = advanced_code_editor.delete_to_next_word_or_end_of_line();
      if (advanced_code_editor.any_dirty_cells()) refresh_render_surfaces();
      if (result) refresh_search_regex_selections_on_current_line();
      return result;


  - name: join_lines
    type: bool
    guards: [ initialized ]
    body: |
      bool join_lines_was_successful = advanced_code_editor.join_lines();
      if (advanced_code_editor.any_dirty_cells()) refresh_render_surfaces();
      if (join_lines_was_successful)
      {
         // HERE
         // 1) clear search_regex_selections on current line and line below it
         search_regex_selections.clear_select_lines({cursor_get_y(), cursor_get_y()+1});
         // 2) move subsequent search_regex_selections up one line
         search_regex_selections.pull_up_from(cursor_get_y()+1, 1);
         // 3) refresh search_regex_selections on newly joined line
         refresh_search_regex_selections_on_select_lines({cursor_get_y()});
      }
      refresh_current_visual_selection_end_to_current_cursor_position();
      return join_lines_was_successful;


  - name: split_lines
    type: bool
    guards: [ initialized ]
    body: |
      bool split_was_successful = advanced_code_editor.split_lines();
      if (advanced_code_editor.any_dirty_cells()) refresh_render_surfaces();
      if (split_was_successful)
      {
         // 1) delete the regex selections on this line
         search_regex_selections.clear_select_lines({cursor_get_y()});
         // 2) push down all regex selections from this line down
         search_regex_selections.push_down_from(cursor_get_y(), 1);
         // 3) refresh selections on the two lines from the split (TODO)
         refresh_search_regex_selections_on_select_lines({cursor_get_y(), cursor_get_y()+1});
      }
      refresh_current_visual_selection_end_to_current_cursor_position();
      return split_was_successful;


  - name: delete_line
    guards: [ initialized ]
    type: bool
    body: |
      bool delete_line_was_successful = advanced_code_editor.delete_line();
      if (advanced_code_editor.any_dirty_cells()) refresh_render_surfaces();
      if (delete_line_was_successful)
      {
         search_regex_selections.clear_select_lines({cursor_get_y()});
         search_regex_selections.pull_up_from(cursor_get_y()+1, 1);
      }
      refresh_current_visual_selection_end_to_current_cursor_position();
      return delete_line_was_successful;


  - name: insert_string_from_input_buffer
    guards: [ initialized ]
    type: bool
    body: |
      bool result = advanced_code_editor.insert_string(input_buffer);
      if (advanced_code_editor.any_dirty_cells()) refresh_render_surfaces();
      refresh_current_visual_selection_end_to_current_cursor_position(); // TODO: consider only if result == true
      if (result) refresh_search_regex_selections_on_current_line();
      return result;


  - name: insert_lines
    guards: [ initialized ]
    type: bool
    parameters:
      - name: lines_to_insert
        type: std::vector<std::string>
        default_argument: '{}'
    body: |
      bool result = advanced_code_editor.insert_lines(lines_to_insert);
      if (advanced_code_editor.any_dirty_cells()) refresh_render_surfaces();

      // reposition regular expression highlights
      search_regex_selections.push_down_from(cursor_get_y(), lines_to_insert.size());

      refresh_current_visual_selection_end_to_current_cursor_position();
      return result;


  - name: set_content
    parameters:
      - name: content
        type: std::string
        default_argument: '""'
    guards: [ initialized ]
    body: |
      advanced_code_editor.set_content(content);
      advanced_code_editor.unmark_content_is_modified();
      if (advanced_code_editor.any_dirty_cells()) refresh_render_surfaces();
      if (currently_grabbing_visual_selection) toggle_currently_grabbing_visual_selection();
      if (currently_grabbing_full_line_visual_selection) toggle_currently_grabbing_full_line_visual_selection();
      search_regex_selections.clear();
      return;


  - name: toggle_commenting_out_current_line
    type: bool
    body: |
      // TODO, this currently only adds the comment
      if (cursor_get_y() < 0) return false;
      if (cursor_get_y() >= advanced_code_editor.get_lines_ref().size()) return false;

      std::string current_line_content = advanced_code_editor.get_lines_ref()[cursor_get_y()];
      int previous_cursor_x = cursor_get_x();
      std::size_t first_non_whitespace_character_pos = current_line_content.find_first_not_of(" ");

      // are the first two characters comments?
      bool current_line_starts_with_comment_chars = false;
      if (current_line_content.substr(first_non_whitespace_character_pos, 2) == "\/\/")
         current_line_starts_with_comment_chars = true;

      if (!current_line_starts_with_comment_chars)
      {
         // insert two slashes
         advanced_code_editor.cursor_set_x(first_non_whitespace_character_pos);
         advanced_code_editor.insert_string("\/\/");
         if (previous_cursor_x >= first_non_whitespace_character_pos)
         {
            advanced_code_editor.cursor_set_x(previous_cursor_x+2);
         }
      }
      else
      {
         // remove two slashes
         advanced_code_editor.cursor_set_x(first_non_whitespace_character_pos);
         advanced_code_editor.delete_character();
         advanced_code_editor.delete_character();
         if (previous_cursor_x >= first_non_whitespace_character_pos)
         {
            advanced_code_editor.cursor_set_x(previous_cursor_x-2);
         }
      }

      if (advanced_code_editor.any_dirty_cells()) refresh_render_surfaces();
      refresh_current_visual_selection_end_to_current_cursor_position();
      refresh_search_regex_selections_on_current_line();

      return true;


  - name: insert_three_spaces_at_start_of_line
    type: bool
    body: |
      if (cursor_get_y() < 0) return false;
      if (cursor_get_y() >= advanced_code_editor.get_lines_ref().size()) return false;

      int previous_cursor_x = cursor_get_x();

      advanced_code_editor.cursor_set_x(0);
      advanced_code_editor.insert_string("   ");
      advanced_code_editor.cursor_set_x(previous_cursor_x+3);

      if (advanced_code_editor.any_dirty_cells()) refresh_render_surfaces();

      refresh_current_visual_selection_end_to_current_cursor_position();
      refresh_search_regex_selections_on_current_line();

      return true;


  - name: insert_blank_line
    type: bool
    body: |
      bool result = insert_lines({ {} });
      return result;


  - name: create_visual_selection_at_current_cursor_location
    type: bool
    body: |
      visual_selections.push_back(CodeRange(cursor_get_x(), cursor_get_y(), cursor_get_x()+1, cursor_get_y()));
      return true;


  - name: destroy_current_visual_selection
    type: bool
    body: |
      visual_selections.clear();
      return true;


  - name: toggle_currently_grabbing_visual_selection
    type: bool
    body: |
      // TODO: have this untoggle if either full_line or not

      // if either is on, turn them both off
      if (currently_grabbing_visual_selection || currently_grabbing_full_line_visual_selection)
      {
         currently_grabbing_visual_selection = false;
         destroy_current_visual_selection();
         currently_grabbing_full_line_visual_selection = false;
         destroy_current_full_line_visual_selection();
      }
      // else if both are off turn on visual
      else
      {
         currently_grabbing_visual_selection = true;
         create_visual_selection_at_current_cursor_location();
      }
      return true;


  - name: create_full_line_visual_selection_at_current_cursor_location
    type: bool
    body: |
      full_line_visual_selections.push_back(
         CodeRange(cursor_get_x(), cursor_get_y(), cursor_get_x()+1, cursor_get_y())
      );
      return true;


  - name: destroy_current_full_line_visual_selection
    type: bool
    body: |
      full_line_visual_selections.clear();
      return true;


  - name: toggle_currently_grabbing_full_line_visual_selection
    type: bool
    body: |
      // TODO: have this untoggle if either full_line or not

      // if either is on, turn them both off
      if (currently_grabbing_visual_selection || currently_grabbing_full_line_visual_selection)
      {
         currently_grabbing_visual_selection = false;
         destroy_current_visual_selection();
         currently_grabbing_full_line_visual_selection = false;
         destroy_current_full_line_visual_selection();
      }
      // else if both are off turn on full line visual
      else
      {
         currently_grabbing_full_line_visual_selection = true;
         create_full_line_visual_selection_at_current_cursor_location();
      }
      return true;


  - name: set_current_visual_selection_end_x
    type: bool
    parameters:
      - name: x_pos
        type: int
        default_argument: 0
    body: |
      // TODO: write test for this conditional behavior
      if (visual_selections.empty() && full_line_visual_selections.empty()) return true;
      if (!visual_selections.empty() && !full_line_visual_selections.empty())
      {
         throw std::runtime_error("unexpected state, both visual_slections and full_line_visual_selections");
      }

      if (!visual_selections.empty())
      {
         visual_selections.back().set_cursor_end_x(x_pos);
      }
      else if (!full_line_visual_selections.empty())
      {
         full_line_visual_selections.back().set_cursor_end_x(x_pos);
      }
      return true;


  - name: set_current_visual_selection_end_y
    type: bool
    parameters:
      - name: y_pos
        type: int
        default_argument: 0
    body: |
      // TODO: write test for this conditional behavior
      if (visual_selections.empty() && full_line_visual_selections.empty()) return true;
      if (!visual_selections.empty() && !full_line_visual_selections.empty())
      {
         throw std::runtime_error("unexpected state, both visual_slections and full_line_visual_selections");
      }
      
      if (!visual_selections.empty())
      {
         visual_selections.back().set_cursor_end_y(y_pos);
      }
      else if (!full_line_visual_selections.empty())
      {
         full_line_visual_selections.back().set_cursor_end_y(y_pos);
      }
      return true;


  - name: refresh_current_visual_selection_end_to_current_cursor_position
    type: bool
    body: |
      // TODO: write test for this conditional behavior
      if (visual_selections.empty() && full_line_visual_selections.empty()) return true;
      if (!visual_selections.empty() && !full_line_visual_selections.empty())
      {
         throw std::runtime_error("unexpected state, both visual_slections and full_line_visual_selections");
      }

      if (!visual_selections.empty())
      {
         visual_selections.back().set_cursor_end_x(cursor_get_x());
         visual_selections.back().set_cursor_end_y(cursor_get_y());
      }
      else if (!full_line_visual_selections.empty())
      {
         full_line_visual_selections.back().set_cursor_end_x(cursor_get_x());
         full_line_visual_selections.back().set_cursor_end_y(cursor_get_y());
      }
      return true;


  - name: replay_action_queue_recording
    type: bool
    body: |
      Hexagon::AdvancedCodeEditor::EventController event_controller(this, build_local_events_dictionary());

      currently_playing_action_queue_recording = true;
      for (auto &action : action_queue_recording.get_actions_ref())
      {
         std::string action_name = action.get_name();
         ActionData action_data1 = action.get_data1();

         event_controller.process_local_event(action_name, action_data1);
      }
      currently_playing_action_queue_recording = false;
      return true;


  - name: yank_selected_text_to_clipboard
    type: bool
    body: |
      // TODO: write test for this conditional behavior
      if (visual_selections.empty() && full_line_visual_selections.empty())
      {
         throw std::runtime_error("aosoadsofaodfaofd");
         return false;
      }
      if (!visual_selections.empty() && !full_line_visual_selections.empty())
      {
         throw std::runtime_error("unexpected state, both visual_slections and full_line_visual_selections");
      }
 
      if (!visual_selections.empty())
      {
         CodeRange visual_selection = visual_selections.back();
         std::vector<std::string> extracted_selection = Hexagon::CodeRangeExtractor(
            &advanced_code_editor.get_lines_ref(),
            &visual_selection
         ).extract();
         ClipboardData::store(extracted_selection);
      }
      else if (!full_line_visual_selections.empty())
      {
         CodeRange full_line_visual_selection = full_line_visual_selections.back();
         std::vector<std::string> extracted_selection = Hexagon::CodeRangeExtractor(
            &advanced_code_editor.get_lines_ref(),
            &full_line_visual_selection
         ).extract_full_lines();
         ClipboardData::store(extracted_selection);
      }
      else
      {
         // TODO: improve this error message
         throw std::runtime_error("RarsoxxxadsofXfjaodfij");
         return false;
      }
      return true;
    body_dependency_symbols:
      - Hexagon::CodeRangeExtractor
      - ClipboardData::store


  - name: paste_selected_text_from_clipboard
    type: bool
    body: |
      std::vector<std::string> retrieved_clipboard_data = ClipboardData::retrieve();
      insert_lines(retrieved_clipboard_data);
      return true;
    body_dependency_symbols:
      - ClipboardData::retrieve


  - name: replace_content_with_contents_of_clipboard
    type: bool
    body: |
      std::vector<std::string> retrieved_clipboard_data = ClipboardData::retrieve();
      Blast::StringJoiner joiner(retrieved_clipboard_data, "\n");
      set_content(joiner.join());
      return true;
    body_dependency_symbols:
      - ClipboardData::retrieve
      - Blast::StringJoiner


  - name: build_local_events_dictionary
    static: true
    type: std::map<std::string, std::function<void(Hexagon::AdvancedCodeEditor::Stage&)>>
    body: |
      std::map<std::string, std::function<void(Hexagon::AdvancedCodeEditor::Stage&)>> local_events = {
         // modification
         { "delete_character", &Hexagon::AdvancedCodeEditor::Stage::delete_character },
         { "delete_word_under_cursor", &Hexagon::AdvancedCodeEditor::Stage::delete_word_under_cursor },
         { "delete_to_end_of_line", &Hexagon::AdvancedCodeEditor::Stage::delete_to_end_of_line },
         { "delete_to_next_word", &Hexagon::AdvancedCodeEditor::Stage::delete_to_next_word },
         { "delete_to_next_word_or_end_of_line",
            &Hexagon::AdvancedCodeEditor::Stage::delete_to_next_word_or_end_of_line },
         { "split_lines", &Hexagon::AdvancedCodeEditor::Stage::split_lines },
         { "join_lines", &Hexagon::AdvancedCodeEditor::Stage::join_lines },
         { "delete_line", &Hexagon::AdvancedCodeEditor::Stage::delete_line },
         { "toggle_commenting_out_current_line",
            &Hexagon::AdvancedCodeEditor::Stage::toggle_commenting_out_current_line },
         { "insert_string_from_input_buffer", &Hexagon::AdvancedCodeEditor::Stage::insert_string_from_input_buffer },
         { "insert_blank_line", &Hexagon::AdvancedCodeEditor::Stage::insert_blank_line },
         { "insert_three_spaces_at_start_of_line",
            &Hexagon::AdvancedCodeEditor::Stage::insert_three_spaces_at_start_of_line },


         // modes
         { ACTION_SET_TO_EDIT_MODE, &Hexagon::AdvancedCodeEditor::Stage::set_to_edit_mode },
         { ACTION_SET_TO_INSERT_MODE, &Hexagon::AdvancedCodeEditor::Stage::set_to_insert_mode },


         // cursor movement
         { "cursor_move_up", &Hexagon::AdvancedCodeEditor::Stage::cursor_move_up },
         { "cursor_move_down", &Hexagon::AdvancedCodeEditor::Stage::cursor_move_down },
         { "cursor_move_left", &Hexagon::AdvancedCodeEditor::Stage::cursor_move_left },
         { "cursor_move_right", &Hexagon::AdvancedCodeEditor::Stage::cursor_move_right },
         { "cursor_move_to_start_of_line", &Hexagon::AdvancedCodeEditor::Stage::cursor_move_to_start_of_line },
         { "cursor_move_to_start_of_file", &Hexagon::AdvancedCodeEditor::Stage::cursor_move_to_start_of_file },
         { "cursor_move_to_end_of_line", &Hexagon::AdvancedCodeEditor::Stage::cursor_move_to_end_of_line },
         { "cursor_move_to_first_non_whitespace_character",
            &Hexagon::AdvancedCodeEditor::Stage::cursor_move_to_first_non_whitespace_character },
         { "cursor_jump_to_next_word_or_last_char",
            &Hexagon::AdvancedCodeEditor::Stage::cursor_jump_to_next_word_or_last_char },
         { "cursor_jump_to_previous_word", &Hexagon::AdvancedCodeEditor::Stage::cursor_jump_to_previous_word },
         { "cursor_jump_up_half_page", &Hexagon::AdvancedCodeEditor::Stage::cursor_jump_up_half_page },
         { "cursor_jump_down_half_page", &Hexagon::AdvancedCodeEditor::Stage::cursor_jump_down_half_page },
         { "cursor_jump_to_next_search_regex_selection",
            &Hexagon::AdvancedCodeEditor::Stage::cursor_jump_to_next_search_regex_selection },
         { "cursor_jump_to_previous_search_regex_selection",
            &Hexagon::AdvancedCodeEditor::Stage::cursor_jump_to_previous_search_regex_selection },


         // first_row_offset
         { "first_row_offset_move_up", &Hexagon::AdvancedCodeEditor::Stage::first_row_offset_move_up },
         { "first_row_offset_move_down", &Hexagon::AdvancedCodeEditor::Stage::first_row_offset_move_down },
         { "first_row_offset_jump_up_half_page",
            &Hexagon::AdvancedCodeEditor::Stage::first_row_offset_jump_up_half_page },
         { "first_row_offset_jump_down_half_page",
            &Hexagon::AdvancedCodeEditor::Stage::first_row_offset_jump_down_half_page },
         { "first_row_offset_adjust_so_cursor_is_vertically_centered",
            &Hexagon::AdvancedCodeEditor::Stage::first_row_offset_adjust_so_cursor_is_vertically_centered },


         // visual_selections
         { "toggle_currently_grabbing_visual_selection",
           &Hexagon::AdvancedCodeEditor::Stage::toggle_currently_grabbing_visual_selection },
         { "toggle_currently_grabbing_full_line_visual_selection",
           &Hexagon::AdvancedCodeEditor::Stage::toggle_currently_grabbing_full_line_visual_selection },


         // file_saving
         { "save_file", &Hexagon::AdvancedCodeEditor::Stage::save_file },


         // clipboard
         { "yank_selected_text_to_clipboard",
           &Hexagon::AdvancedCodeEditor::Stage::yank_selected_text_to_clipboard },
         { "paste_selected_text_from_clipboard",
           &Hexagon::AdvancedCodeEditor::Stage::paste_selected_text_from_clipboard },
         { "replace_content_with_contents_of_clipboard",
           &Hexagon::AdvancedCodeEditor::Stage::replace_content_with_contents_of_clipboard },


         // action queue
         { "replay_action_queue_recording",
           &Hexagon::AdvancedCodeEditor::Stage::replay_action_queue_recording },

      };
      return local_events;


  - name: build_keyboard_command_mapping_for_edit_mode
    static: true
    type: AllegroFlare::KeyboardCommandMapper
    body: |
      AllegroFlare::KeyboardCommandMapper result;
      result.set_mapping(ALLEGRO_KEY_K, 0, { "cursor_move_up" });
      result.set_mapping(ALLEGRO_KEY_J, 0, { "cursor_move_down" });
      result.set_mapping(ALLEGRO_KEY_J, ALLEGRO_KEYMOD_SHIFT, { "join_lines" });
      result.set_mapping(ALLEGRO_KEY_H, 0, { "cursor_move_left" });
      result.set_mapping(ALLEGRO_KEY_L, 0, { "cursor_move_right" });
      result.set_mapping(ALLEGRO_KEY_0, 0, { "cursor_move_to_start_of_line" });
      result.set_mapping(ALLEGRO_KEY_4, ALLEGRO_KEYMOD_SHIFT, { "cursor_move_to_end_of_line" });
      result.set_mapping(ALLEGRO_KEY_W, 0, { "cursor_jump_to_next_word_or_last_char" });
      result.set_mapping(ALLEGRO_KEY_B, 0, { "cursor_jump_to_previous_word" });
      result.set_mapping(ALLEGRO_KEY_U, AllegroFlare::KeyboardCommandMapper::CTRL, {
         "cursor_jump_up_half_page",
         "first_row_offset_adjust_so_cursor_is_vertically_centered",
         });
      result.set_mapping(ALLEGRO_KEY_D, AllegroFlare::KeyboardCommandMapper::CTRL, {
         "cursor_jump_down_half_page",
         "first_row_offset_adjust_so_cursor_is_vertically_centered",
         });
      result.set_mapping(ALLEGRO_KEY_B, 0, { "cursor_jump_to_previous_word" });
      result.set_mapping(ALLEGRO_KEY_N, 0, { "cursor_jump_to_next_search_regex_selection" });
      result.set_mapping(ALLEGRO_KEY_N, ALLEGRO_KEYMOD_SHIFT, { "cursor_jump_to_previous_search_regex_selection" });
      result.set_mapping(ALLEGRO_KEY_Y, AllegroFlare::KeyboardCommandMapper::CTRL, { "first_row_offset_move_up" });
      result.set_mapping(ALLEGRO_KEY_E, AllegroFlare::KeyboardCommandMapper::CTRL, { "first_row_offset_move_down" });
      result.set_mapping(ALLEGRO_KEY_X, 0, { "delete_character" });
      result.set_mapping(ALLEGRO_KEY_BACKSPACE, ALLEGRO_KEYMOD_SHIFT, { "delete_line" });
      result.set_mapping(ALLEGRO_KEY_S, AllegroFlare::KeyboardCommandMapper::COMMAND, { "save_file" });
      result.set_mapping(ALLEGRO_KEY_I, 0, { "set_to_insert_mode" });
      result.set_mapping(ALLEGRO_KEY_SLASH, AllegroFlare::KeyboardCommandMapper::SHIFT, {
         "toggle_commenting_out_current_line"
         });
      result.set_mapping(ALLEGRO_KEY_Z, 0, {
         "first_row_offset_adjust_so_cursor_is_vertically_centered",
         });
      result.set_mapping(ALLEGRO_KEY_I, ALLEGRO_KEYMOD_SHIFT, {
         "cursor_move_to_first_non_whitespace_character",
         "set_to_insert_mode",
         });
      result.set_mapping(ALLEGRO_KEY_S, 0, {
         "delete_character",
         "set_to_insert_mode",
         });
      result.set_mapping(ALLEGRO_KEY_A, 0, {
         "cursor_move_right",
         "set_to_insert_mode",
         });
      result.set_mapping(ALLEGRO_KEY_A, ALLEGRO_KEYMOD_SHIFT, {
         "cursor_move_to_end_of_line",
         "cursor_move_right",
         "set_to_insert_mode",
         });
      result.set_mapping(ALLEGRO_KEY_O, 0, {
         "cursor_move_down",
         "insert_blank_line",
         "cursor_move_to_start_of_line",
         "set_to_insert_mode",
         });
      result.set_mapping(ALLEGRO_KEY_O, ALLEGRO_KEYMOD_SHIFT, {
         "insert_blank_line",
         "cursor_move_to_start_of_line",
         "set_to_insert_mode",
         });
      result.set_mapping(ALLEGRO_KEY_FULLSTOP, ALLEGRO_KEYMOD_SHIFT, {
         "insert_three_spaces_at_start_of_line",
         });
      result.set_mapping(ALLEGRO_KEY_V, 0, { "toggle_currently_grabbing_visual_selection" });
      result.set_mapping(ALLEGRO_KEY_V, ALLEGRO_KEYMOD_SHIFT, {
         "toggle_currently_grabbing_full_line_visual_selection"
      });
      result.set_mapping(ALLEGRO_KEY_Y, 0, { "yank_selected_text_to_clipboard" });
      result.set_mapping(ALLEGRO_KEY_P, ALLEGRO_KEYMOD_SHIFT, { "paste_selected_text_from_clipboard" });
      result.set_mapping(ALLEGRO_KEY_ENTER, 0, { "cursor_move_down", "insert_blank_line" });
      result.set_mapping(ALLEGRO_KEY_ENTER, ALLEGRO_KEYMOD_SHIFT, { "insert_blank_line" });
      result.set_mapping(ALLEGRO_KEY_P,
            AllegroFlare::KeyboardCommandMapper::COMMAND | AllegroFlare::KeyboardCommandMapper::SHIFT,
            { "replace_content_with_contents_of_clipboard" }
      );
      result.set_mapping(ALLEGRO_KEY_FULLSTOP, 0, { "replay_action_queue_recording" });

      return result;


  - name: build_keyboard_command_mapping_for_insert_mode
    static: true
    type: AllegroFlare::KeyboardCommandMapper
    body: |
      AllegroFlare::KeyboardCommandMapper result;
      result.set_mapping(ALLEGRO_KEY_UP, 0, { "cursor_move_up" });
      result.set_mapping(ALLEGRO_KEY_DOWN, 0, { "cursor_move_down" });
      result.set_mapping(ALLEGRO_KEY_LEFT, 0, { "cursor_move_left" });
      result.set_mapping(ALLEGRO_KEY_RIGHT, 0, { "cursor_move_right" });

      result.set_mapping(ALLEGRO_KEY_ENTER, 0, { "split_lines", "cursor_move_down", "cursor_move_to_start_of_line" });
      result.set_mapping(ALLEGRO_KEY_BACKSPACE, 0, { "cursor_move_left", "delete_character" });

      result.set_mapping(ALLEGRO_KEY_OPENBRACE, AllegroFlare::KeyboardCommandMapper::CTRL, { "set_to_edit_mode" });
      result.set_mapping(ALLEGRO_KEY_S, AllegroFlare::KeyboardCommandMapper::COMMAND, { "save_file" });
      return result;


  - name: cursor_move_to
    type: bool
    parameters:
      - name: x
        type: int
        default_argument: 0
      - name: y
        type: int
        default_argument: 0
    body: |
      advanced_code_editor.cursor_move_to(x, y);
      return true;


  - name: render
    virtual: true
    override: true
    guards: [ initialized ]
    body: |
      placement3d &place = get_place();
      std::vector<std::string> &lines = advanced_code_editor.get_lines_ref();

      std::vector<Hexagon::AdvancedCodeEditor::Selection> selections = {
         Hexagon::AdvancedCodeEditor::Selection{
            //std::vector<CodeRange>{ CodeRange{4, 5, 10, 6} },
         },
      };


      //ALLEGRO_COLOR null_space_color = ALLEGRO_COLOR{0, 0, 0, 0.3};

      Hexagon::AdvancedCodeEditor::Renderer renderer(
         &text_mesh,
         surface_render,
         &advanced_code_editor.get_cursor_ref(),
         &selections,
         &search_regex_selections,
         &visual_selections,
         &full_line_visual_selections,
         &code_message_point_manager.get_code_message_points_ref(),
         &lines,
         place.size.x,
         place.size.y,
         is_in_insert_mode(),
         0.0f,
         first_row_offset,
         true, // show line numbers
         obtain_text_font(),
         advanced_code_editor.get_content_is_modified(),
         represents_symlink,
         advanced_code_editor.is_cursor_in_bounds()
      );

      renderer.set_backfill_color(get_backfill_color());
      renderer.set_null_space_color(get_null_space_color());
      renderer.set_line_numbers_color(get_on_color());

      place.start_transform();
      renderer.render();
      place.restore_transform();

      return;
    body_dependency_symbols:
      - Hexagon::AdvancedCodeEditor::Renderer


  - name: process_local_event
    virtual: true
    override: true
    parameters:
      - name: event_name
        type: std::string
        default_argument: '""'
      - name: action_data
        type: ActionData
        default_argument: "ActionData()"
    body: |
      Hexagon::AdvancedCodeEditor::EventController event_controller(this, build_local_events_dictionary());
      event_controller.process_local_event(event_name, action_data);
      return;
    body_dependency_symbols:
      - Hexagon::AdvancedCodeEditor::EventController


  - name: process_event
    virtual: true
    override: true
    parameters:
      - name: event
        type: ALLEGRO_EVENT&
        default_argument: "get_a_default_empty_event_ref()"
    body: |
      AllegroFlare::KeyboardCommandMapper keyboard_command_mapping;
      if (is_in_insert_mode()) keyboard_command_mapping = build_keyboard_command_mapping_for_insert_mode();
      else if (is_in_edit_mode()) keyboard_command_mapping = build_keyboard_command_mapping_for_edit_mode();

      Hexagon::AdvancedCodeEditor::EventController event_controller(
            this,
            build_local_events_dictionary(),
            keyboard_command_mapping
         );
      event_controller.process_event(event);
      return;
    body_dependency_symbols:
      - Hexagon::AdvancedCodeEditor::EventController


  - name: obtain_text_font
    private: true
    type: ALLEGRO_FONT*
    guards: [ font_bin ]
    body: |
      return font_bin->auto_get("Menlo-Regular.ttf -20");


  - name: get_lines
    xprivate: true
    type: std::vector<std::string>
    body: |
      return advanced_code_editor.get_lines();


  - name: get_cursor
    xprivate: true
    type: Hexagon::AdvancedCodeEditor::Cursor
    body: |
      return advanced_code_editor.get_cursor_ref();


  - name: cursor_get_x
    private: true
    type: int
    body: |
      return advanced_code_editor.get_cursor_ref().get_x();


  - name: cursor_get_y
    private: true
    type: int
    body: |
      return advanced_code_editor.get_cursor_ref().get_y();


  - name: is_in_edit_mode
    type: bool
    body: |
      return mode == MODE_EDIT;


  - name: is_in_insert_mode
    type: bool
    body: |
      return mode == MODE_INSERT;


  - name: calculate_natural_width
    type: int
    body: |
      return num_columns * text_mesh.get_cell_width();


  - name: calculate_half_num_rows
    type: int
    body: |
      return num_rows / 2;


  - name: calculate_one_third_num_rows
    type: int
    body: |
      return num_rows / 3;


  - name: calculate_natural_height
    type: int
    body: |
      return num_rows * text_mesh.get_cell_height();


  - name: refresh_render_surfaces
    type: void
    body: |
      AllegroFlare::Timer timer;

      //std::cout << "------------" << std::endl;
      //std::cout << "-num dirty cells: " << advanced_code_editor.dirty_cell_count() << std::endl;

      timer.reset(); timer.start();
      //refresh_dirty_cells_on_text_mesh();
      refresh_text_mesh_respecting_first_row_offset();
      //timer.pause(); std::cout << " refresh_dirty_cells_on_text_mesh: "
      //                         << timer.get_elapsed_time_microseconds() << std::endl;

      timer.reset(); timer.start();
      refresh_dirty_cells_on_surface_render_respecting_first_row_offset();
      //timer.pause(); std::cout << " refresh_dirty_cells_on_surface_render_respecting_first_row_offset: "
      //                         << timer.get_elapsed_time_microseconds() << std::endl;

      advanced_code_editor.dirty_grid_clear();

      return;
    body_dependency_symbols:
      - AllegroFlare::Timer


  - name: refresh_dirty_cells_on_surface_render_respecting_first_row_offset
    private: true
    guards: [ initialized ]
    body: |
      ALLEGRO_STATE previous_render_state;
      al_store_state(&previous_render_state, ALLEGRO_STATE_TARGET_BITMAP | ALLEGRO_STATE_BLENDER);
      al_set_target_bitmap(surface_render);
      al_set_blender(ALLEGRO_ADD, ALLEGRO_ONE, ALLEGRO_ZERO);

      std::vector<std::pair<int, int>> transposed_dirty_cells;
      for (auto dirty_cell : advanced_code_editor.get_dirty_cells())
      {
         std::get<1>(dirty_cell) -= first_row_offset;
         transposed_dirty_cells.push_back(dirty_cell);
      }

      text_mesh.render_only_select_cells(transposed_dirty_cells);
         //advanced_code_editor.get_dirty_cells());

      al_restore_state(&previous_render_state);
      return;


  - name: refresh_dirty_cells_on_text_mesh
    private: true
    guards: [ initialized ]
    body: |
      char clear_char = '\0';
      //ALLEGRO_COLOR clear_color = ALLEGRO_COLOR{0.0f, 0.0f, 0.0f, 0.0f};
      //ALLEGRO_COLOR on_color = ALLEGRO_COLOR{1.0f, 1.0f, 1.0f, 1.0f};
      std::vector<std::string> &lines = advanced_code_editor.get_lines_ref();

      int text_mesh_max_x = num_columns;
      int text_mesh_max_y = num_rows;

      for (auto &cell : advanced_code_editor.get_dirty_cells())
      {
         char char_to_set = clear_char;
         ALLEGRO_COLOR color_to_set = clear_color;
         int &x = cell.first;
         int &y = cell.second;

         if (y >= text_mesh_max_y) continue;
         if (x >= text_mesh_max_x) continue;

         if (y < lines.size())
         {
            if (x < lines[y].size())
            {
               char_to_set = lines[y][x];
               color_to_set = on_color;
            }
         }

         text_mesh.set_cell_character(x, y, char_to_set);
         text_mesh.set_cell_color(x, y, color_to_set);
      }
      return;


  - name: refresh_text_mesh_respecting_first_row_offset
    private: true
    guards: [ initialized ]
    body: |
      // TODO: optimize this. It does no need to wipe and refresh the entire mesh,
      // it should be able to move existing vertexes by the previous offset.
      // There's definitely some fun research to be done here.

      char clear_char = '\0';
      //ALLEGRO_COLOR clear_color = ALLEGRO_COLOR{0.0f, 0.0f, 0.0f, 0.0f};
      //ALLEGRO_COLOR on_color = ALLEGRO_COLOR{1.0f, 1.0f, 1.0f, 1.0f};
      std::vector<std::string> &lines = advanced_code_editor.get_lines_ref();

      for (unsigned y=0; y<num_rows; y++)
      {
         for (unsigned x=0; x<num_columns; x++)
         {
            char char_to_set = clear_char;
            ALLEGRO_COLOR color_to_set = clear_color;

            int this_row_num = first_row_offset + y;
            if (this_row_num >= 0 && this_row_num < lines.size())
            {
               if (x < lines[this_row_num].size())
               {
                  char_to_set = lines[this_row_num][x];
                  color_to_set = on_color;
               }
            }

            text_mesh.set_cell_character(x, y, char_to_set);
            text_mesh.set_cell_color(x, y, color_to_set);
         }
      }
      filter_text_mesh_for_syntax_highlights();
      filter_text_mesh_for_comments();
      filter_text_mesh_for_test_case();
      if (show_line_too_long) filter_text_mesh_for_line_too_long();
      return;


  - name: filter_text_mesh_for_syntax_highlights
    private: true
    type: void
    body: |
      //ALLEGRO_COLOR highlight_color = al_color_html("f590b2"); // pink
      //ALLEGRO_COLOR highlight_color = al_color_html("a2a0f5"); // a purpley color
      ALLEGRO_COLOR highlight_color = get_syntax_highlight_color();
      //ALLEGRO_COLOR{0.0f, 0.0f, 0.0f, 0.0f};
      std::vector<std::string> &lines = advanced_code_editor.get_lines_ref();

      std::vector<std::string> strings_to_match = {
         "properties:",
         "  - class:",
         "  - name:",
         "    constructor_arg:",
         "    getter:",
         "    const:",
         "    constexpr:",
         "    static:",
         "    type:",
         "    setter:",
         "    init_with:",
         "    getter_ref:",
         "    private:",
         "    guards:",
         "    parameters:",
         "      - name:",
         "        type:",
         "        default_argument:",
         "    body:",
         "    body_dependency_symbols:",
         "enums:",
         "  - name:",
         "  - enumerators:",
         "    enumerators:",
         "  - type:",
         "    type:",
         "  - start_from:",
         "    start_from:",
         "headers:",
         "parent_classes:",
         "    class:",
         "    scope:",
         "functions:",
         "    virtual:",
         "    override:",
         "dependencies:",
         "  - symbol:",
         "    headers:",
      };

      for (unsigned y=0; y<num_rows; y++)
      {
         int this_row_num = first_row_offset + y;
         if (this_row_num >= 0 && this_row_num < lines.size())
         {
            std::string &this_line = lines[this_row_num];
            for (auto &string_to_match : strings_to_match)
            {
               if (this_line.find(string_to_match) == std::size_t(0))
               {
                  int num_characters_to_process = std::min((int)string_to_match.size(), num_columns);
                  for (unsigned c=0; c<num_characters_to_process; c++)
                  {
                     text_mesh.set_cell_color(c, y, highlight_color);
                  }
               }
            }
         }
      }
      return;
    body_dependency_symbols:
      - std::min


  - name: filter_text_mesh_for_comments
    private: true
    body: |
      std::vector<std::string> &lines = advanced_code_editor.get_lines_ref();
      //std::string string_to_match = " //";
      std::string string_to_match = "//";

      for (unsigned y=0; y<num_rows; y++)
      {
         int this_row_num = first_row_offset + y;
         if (this_row_num >= 0 && this_row_num < lines.size())
         {
            std::string &this_line = lines[this_row_num];
            //for (auto &string_to_match : strings_to_match)
            //{
               std::size_t found_pos = this_line.find(string_to_match);
               if (found_pos != std::string::npos)
               {
                  int end_to_process = std::min((int)this_line.size(), num_columns);
                  for (unsigned c=found_pos; c<end_to_process; c++)
                  {
                     text_mesh.set_cell_color(c, y, comment_color);
                  }
               }
            //}
         }
      }
      return;


  - name: filter_text_mesh_for_test_case
    private: true
    body: |
      //ALLEGRO_COLOR highlight_color = ALLEGRO_COLOR{0.5f, 0.5f, 0.5f, 0.5f};
      //ALLEGRO_COLOR highlight_color = al_color_html("a2a0f5"); // a purpley color
      ALLEGRO_COLOR highlight_color = get_syntax_highlight_color();
      std::vector<std::string> &lines = advanced_code_editor.get_lines_ref();
      std::vector<std::string> strings_to_match = {
         "TEST(",
         "TEST_F(",
      };

      for (unsigned y=0; y<num_rows; y++)
      {
         int this_row_num = first_row_offset + y;
         if (this_row_num >= 0 && this_row_num < lines.size())
         {
            std::string &this_line = lines[this_row_num];
            for (auto &string_to_match : strings_to_match)
            {
               std::size_t found_pos = this_line.find(string_to_match);
               if (found_pos == std::size_t(0))
               {
                  // test line matched
                  int num_characters_to_process = std::min((int)this_line.size(), num_columns);
                  for (unsigned c=0; c<num_characters_to_process; c++)
                  {
                     text_mesh.set_cell_color(c, y, highlight_color);
                  }
                  // TODO: check one line forward
                  // if any ) is present at end-of-line
               }
            }
         }
      }
      return;
    body_dependency_symbols:
      - std::min


  - name: filter_text_mesh_for_line_too_long
    private: true
    body: |
      ALLEGRO_COLOR line_too_long_color = ALLEGRO_COLOR{0.9f, 0.4f, 0.42f, 1.0f};
      std::vector<std::string> &lines = advanced_code_editor.get_lines_ref();

      for (unsigned y=0; y<num_rows; y++)
      {
         int this_row_num = first_row_offset + y;
         if (this_row_num < 0 && this_row_num >= lines.size()) continue;
         bool this_line_is_too_long = false;

         std::string &this_line = lines[this_row_num];
         
         if (this_line.size() > max_line_length) this_line_is_too_long = true;

         if (this_line_is_too_long)
         {
            int num_characters_to_process = std::min((int)this_line.size(), num_columns);
            for (unsigned c=0; c<num_characters_to_process; c++)
            {
               text_mesh.set_cell_color(c, y, line_too_long_color);
            }
         }
      }
      return;


  - name: refresh_text_mesh
    private: true
    guards: [ initialized ]
    body: |
      char clear_char = '\0';

      std::vector<std::string> &lines = advanced_code_editor.get_lines_ref();

      for (unsigned y=0; y<num_rows; y++)
      {
         for (unsigned x=0; x<num_columns; x++)
         {
            char char_to_set = clear_char;
            ALLEGRO_COLOR color_to_set = clear_color;

            if (y < lines.size())
            {
               if (x < lines[y].size())
               {
                  char_to_set = lines[y][x];
                  color_to_set = on_color;
               }
            }

            text_mesh.set_cell_character(x, y, char_to_set);
            text_mesh.set_cell_color(x, y, color_to_set);
         }
      }
      return;


  - name: build_dirty_grid_from_lines_respecting_offset
    xprivate: true
    type: Hexagon::DirtyGrid
    body: |
      std::vector<std::string> &lines = advanced_code_editor.get_lines_ref();
      Hexagon::DirtyGrid result;

      for (int row=0; row<num_rows; row++)
      {
         int line_num_to_render = row + first_row_offset;
         if (line_num_to_render < 0 || line_num_to_render >= lines.size()) continue;

         result.mark_row_as_dirty(row, 0, lines[line_num_to_render].length());
      }
      return result;


dependencies:


  - symbol: Hexagon::WordRangesFinder
    headers: [ Hexagon/WordRangesFinder.hpp ]
  - symbol: std::min
    headers: [ algorithm ]
  - symbol: Hexagon::CodeRangeExtractor
    headers: [ Hexagon/CodeRangeExtractor.hpp ]
  - symbol: ClipboardData::store
    headers: [ Hexagon/ClipboardData.hpp ]
  - symbol: ClipboardData::retrieve
    headers: [ Hexagon/ClipboardData.hpp ]
  - symbol: std::vector<CodeRange>
    headers: [ vector, Hexagon/CodeRange.hpp ]
  - symbol: Hexagon::SymlinkToucher
    headers: [ Hexagon/SymlinkToucher.hpp ]
  - symbol: std::vector<Hexagon::AdvancedCodeEditor::Selection>
    headers: [ vector, Hexagon/AdvancedCodeEditor/Selection.hpp ]
  - symbol: Hexagon::AdvancedCodeEditor::SearchRegexToSelectionsConverter
    headers: [ Hexagon/AdvancedCodeEditor/SearchRegexToSelectionsConverter.hpp ]
  - symbol: Hexagon::AdvancedCodeEditor::Selection
    headers: [ Hexagon/AdvancedCodeEditor/Selection.hpp ]
  - symbol: std::vector<std::pair<int, int>>
    headers: [ vector, utility ]
  - symbol: std::map<std::string, std::function<void(Hexagon::AdvancedCodeEditor::Stage&)>>
    headers: [ map, string, functional, Hexagon/AdvancedCodeEditor/Stage.hpp ]
  - symbol: StageInterface
    headers: [ Hexagon/StageInterface.hpp ]
  - symbol: placement3d
    headers: [ allegro_flare/placement3d.h ]
  - symbol: AllegroFlare::FontBin*
    headers: [ AllegroFlare/FontBin.hpp ]
  - symbol: AllegroFlare::Timer
    headers: [ AllegroFlare/Timer.hpp ]
  - symbol: ALLEGRO_BITMAP*
    headers: [ allegro5/allegro.h ]
  - symbol: ALLEGRO_COLOR
    headers: [ allegro5/allegro.h ]
  - symbol: ALLEGRO_FONT*
    headers: [ allegro5/allegro_font.h ]
  - symbol: ALLEGRO_EVENT
    headers: [ allegro5/allegro.h ]
  - symbol: ALLEGRO_EVENT&
    headers: [ allegro5/allegro.h ]
  - symbol: Hexagon::DirtyGrid
    headers: [ Hexagon/DirtyGrid.hpp ]
  - symbol: ActionData
    headers: [ Hexagon/ActionData.hpp ]
  - symbol: Hexagon::AdvancedCodeEditor::AdvancedCodeEditor
    headers: [ Hexagon/AdvancedCodeEditor/AdvancedCodeEditor.hpp ]
  - symbol: Hexagon::AdvancedCodeEditor::Renderer
    headers: [ Hexagon/AdvancedCodeEditor/Renderer.hpp ]
  - symbol: AllegroFlare::KeyboardCommandMapper
    headers: [ AllegroFlare/KeyboardCommandMapper.hpp ]
  - symbol: Hexagon::Elements::TextMesh
    headers: [ Hexagon/Elements/TextMesh.hpp ]
  - symbol: Hexagon::AdvancedCodeEditor::Cursor
    headers: [ Hexagon/AdvancedCodeEditor/Cursor.hpp ]
  - symbol: Hexagon::AdvancedCodeEditor::EventController
    headers: [ Hexagon/AdvancedCodeEditor/EventController.hpp ]
  - symbol: ::save_file
    headers: [ Hexagon/util.hpp ]
  - symbol: Hexagon::CodeMessagePointManager
    headers: [ vector, Hexagon/CodeMessagePointManager.hpp ]
  - symbol: std::vector<CodeMessagePoint>
    headers: [ vector, Hexagon/CodeMessagePoint.hpp ]

  - symbol: ALLEGRO_BITMAP
    headers: [ allegro5/allegro.h ]
  - symbol: ALLEGRO_FONT
    headers: [ allegro5/allegro_font.h ]
  - symbol: AllegroFlare::FontBin
    headers: [ AllegroFlare/FontBin.hpp ]
  - symbol: CodeMessagePoint
    headers: [ Hexagon/CodeMessagePoint.hpp ]
  - symbol: CodeRange
    headers: [ Hexagon/CodeRange.hpp ]
  - symbol: Hexagon::AdvancedCodeEditor::Stage
    headers: [ Hexagon/AdvancedCodeEditor/Stage.hpp ]
  - symbol: std::function
    headers: [ functional ]
  - symbol: Blast::StringJoiner
    headers: [ Blast/StringJoiner.hpp ]
  - symbol: ActionQueueRecording
    headers: [ Hexagon/ActionQueueRecording.hpp ]


