parent_classes:


  - class: 'StageInterface'
    scope: public
    init_with: "StageInterface::ADVANCED_CODE_EDITOR"


properties:


  - name: font_bin
    type: AllegroFlare::FontBin*
    init_with: nullptr
    constructor_arg: true
  - name: num_columns
    type: int
    init_with: 0
    setter: false
    constructor_arg: true
  - name: num_rows
    type: int
    init_with: 0
    setter: false
    constructor_arg: true
  - name: text_mesh
    type: Hexagon::Elements::TextMesh
    init_with: '{nullptr, num_columns, num_rows}'
  - name: advanced_code_editor
    type: Hexagon::AdvancedCodeEditor::AdvancedCodeEditor
    init_with: '{}'
    getter_ref: true
  - name: input_buffer
    type: std::string
    init_with: '""'
    getter: true
    getter_ref: true
    setter: true
  - name: mode
    type: int
    init_with: 0
  - name: a_default_empty_event
    static: true
    type: ALLEGRO_EVENT
    init_with: "{}"
    getter_ref: true
  - name: initialized
    type: bool
    init_with: false


functions:


  - name: initialize
    guards: [ al_is_system_installed(), font_bin ]
    body: |
      if (initialized) return;

      text_mesh.set_font(obtain_text_font());
      text_mesh.initialize();

      advanced_code_editor.cursor_set_width(text_mesh.get_cell_width());
      advanced_code_editor.cursor_set_height(text_mesh.get_cell_height());

      initialized = true;
      return;


  - name: set_to_edit_mode
    type: bool
    body: |
      mode = 0;
      return true;


  - name: set_to_insert_mode
    type: bool
    body: |
      mode = 1;
      return true;


  - name: cursor_move_up
    type: bool
    body: |
      return advanced_code_editor.cursor_move_up();


  - name: cursor_move_down
    type: bool
    body: |
      return advanced_code_editor.cursor_move_down();


  - name: cursor_move_left
    type: bool
    body: |
      return advanced_code_editor.cursor_move_left();


  - name: cursor_move_right
    type: bool
    body: |
      return advanced_code_editor.cursor_move_right();


  - name: cursor_move_to_start_of_line
    type: bool
    body: |
      return advanced_code_editor.cursor_move_to_start_of_line();


  - name: delete_character
    type: bool
    body: |
      bool result = advanced_code_editor.delete_character();
      if (result == true) refresh_text_mesh();
      return result;


  - name: join_lines
    type: bool
    body: |
      bool result = advanced_code_editor.join_lines();
      if (result == true) refresh_text_mesh();
      return result;


  - name: split_lines
    type: bool
    body: |
      bool result = advanced_code_editor.split_lines();
      if (result == true) refresh_text_mesh();
      return result;


  - name: delete_line
    type: bool
    body: |
      bool result = advanced_code_editor.delete_line();
      if (result == true) refresh_text_mesh();
      return result;


  - name: insert_string_from_input_buffer
    type: bool
    body: |
      bool result = advanced_code_editor.insert_string(input_buffer);
      if (result == true) refresh_text_mesh();
      return result;


  - name: insert_three_spaces_at_start_of_line
    type: bool
    body: |
      // TODO
      return false;


  - name: build_local_events_dictionary
    static: true
    type: std::map<std::string, std::function<void(Hexagon::AdvancedCodeEditor::Stage&)>>
    body: |
      std::map<std::string, std::function<void(Hexagon::AdvancedCodeEditor::Stage&)>> local_events = {
         { "cursor_move_up", &Hexagon::AdvancedCodeEditor::Stage::cursor_move_up },
         { "cursor_move_down", &Hexagon::AdvancedCodeEditor::Stage::cursor_move_down },
         { "cursor_move_left", &Hexagon::AdvancedCodeEditor::Stage::cursor_move_left },
         { "cursor_move_right", &Hexagon::AdvancedCodeEditor::Stage::cursor_move_right },
         { "delete_character", &Hexagon::AdvancedCodeEditor::Stage::delete_character },
         { "split_lines", &Hexagon::AdvancedCodeEditor::Stage::split_lines },
         { "join_lines", &Hexagon::AdvancedCodeEditor::Stage::join_lines },
         { "delete_line", &Hexagon::AdvancedCodeEditor::Stage::delete_line },
         { "insert_string_from_input_buffer", &Hexagon::AdvancedCodeEditor::Stage::insert_string_from_input_buffer },
         { "set_to_edit_mode", &Hexagon::AdvancedCodeEditor::Stage::set_to_edit_mode },
         { "set_to_insert_mode", &Hexagon::AdvancedCodeEditor::Stage::set_to_insert_mode },
         { "cursor_move_to_start_of_line", &Hexagon::AdvancedCodeEditor::Stage::cursor_move_to_start_of_line },
      };
      return local_events;


  - name: build_keyboard_command_mapping_for_edit_mode
    static: true
    type: KeyboardCommandMapper
    body: |
      KeyboardCommandMapper result;
      result.set_mapping(ALLEGRO_KEY_K, 0, { "cursor_move_up" });
      result.set_mapping(ALLEGRO_KEY_J, 0, { "cursor_move_down" });
      result.set_mapping(ALLEGRO_KEY_H, 0, { "cursor_move_left" });
      result.set_mapping(ALLEGRO_KEY_L, 0, { "cursor_move_right" });
      result.set_mapping(ALLEGRO_KEY_X, 0, { "delete_character" });
      result.set_mapping(ALLEGRO_KEY_BACKSPACE, ALLEGRO_KEYMOD_SHIFT, { "delete_line" });
      result.set_mapping(ALLEGRO_KEY_I, 0, { "set_to_insert_mode" });
      return result;


  - name: build_keyboard_command_mapping_for_insert_mode
    static: true
    type: KeyboardCommandMapper
    body: |
      KeyboardCommandMapper result;
      result.set_mapping(ALLEGRO_KEY_UP, 0, { "cursor_move_up" });
      result.set_mapping(ALLEGRO_KEY_DOWN, 0, { "cursor_move_down" });
      result.set_mapping(ALLEGRO_KEY_LEFT, 0, { "cursor_move_left" });
      result.set_mapping(ALLEGRO_KEY_RIGHT, 0, { "cursor_move_right" });
      result.set_mapping(ALLEGRO_KEY_0, 0, { "cursor_move_to_start_of_line" });

      result.set_mapping(ALLEGRO_KEY_ENTER, 0, { "split_lines", "cursor_move_down", "cursor_move_to_start_of_line" });
      result.set_mapping(ALLEGRO_KEY_BACKSPACE, 0, { "cursor_move_left", "delete_character" });

      result.set_mapping(ALLEGRO_KEY_OPENBRACE, KeyboardCommandMapper::CTRL, { "set_to_edit_mode" });
      return result;


  - name: insert_lines
    type: bool
    parameters:
      - name: lines_to_insert
        type: std::vector<std::string>
        default_argument: '{}'
    body: |
      bool result = advanced_code_editor.insert_lines(lines_to_insert);
      if (result == true) refresh_text_mesh();
      return result;


  - name: cursor_move_to
    type: bool
    parameters:
      - name: x
        type: int
        default_argument: 0
      - name: y
        type: int
        default_argument: 0
    body: |
      advanced_code_editor.cursor_move_to(x, y);
      return true;


  - name: set_content
    parameters:
      - name: content
        type: std::string
        default_argument: '""'
    guards: [ initialized ]
    body: |
      bool result = advanced_code_editor.set_content(content);
      if (result == true) refresh_text_mesh();
      return;


  - name: render
    virtual: true
    override: true
    guards: [ initialized ]
    body: |
      Hexagon::AdvancedCodeEditor::Renderer renderer(
         &text_mesh,
         &advanced_code_editor.get_cursor_ref(),
         get_place().size.x,
         get_place().size.y,
         is_in_insert_mode()
      );

      //get_place().start_transform();
      renderer.render();
      //al_draw_text(obtain_text_font(), al_color_name("blue"), 20, 20, 0, is_in_insert_mode() ? "INSERT" : "EDIT");
      //get_place().restore_transform();

      return;
    body_dependency_symbols:
      - Hexagon::AdvancedCodeEditor::Renderer


  - name: process_local_event
    virtual: true
    override: true
    parameters:
      - name: event_name
        type: std::string
        default_argument: '""'
      - name: action_data
        type: ActionData
        default_argument: "ActionData()"
    body: |
      Hexagon::AdvancedCodeEditor::EventController event_controller(this, build_local_events_dictionary());
      event_controller.process_local_event(event_name, action_data);
      return;
    body_dependency_symbols:
      - Hexagon::AdvancedCodeEditor::EventController


  - name: process_event
    virtual: true
    override: true
    parameters:
      - name: event
        type: ALLEGRO_EVENT&
        default_argument: "get_a_default_empty_event_ref()"
    body: |
      KeyboardCommandMapper keyboard_command_mapping;
      if (is_in_insert_mode()) keyboard_command_mapping = build_keyboard_command_mapping_for_insert_mode();
      else if (is_in_edit_mode()) keyboard_command_mapping = build_keyboard_command_mapping_for_edit_mode();

      Hexagon::AdvancedCodeEditor::EventController event_controller(
            this,
            build_local_events_dictionary(),
            keyboard_command_mapping
         );
      event_controller.process_event(event);
      return;
    body_dependency_symbols:
      - Hexagon::AdvancedCodeEditor::EventController


  - name: obtain_text_font
    private: true
    type: ALLEGRO_FONT*
    guards: [ font_bin ]
    body: |
      return font_bin->auto_get("Menlo-Regular.ttf -30");


  - name: get_lines
    private: true
    type: std::vector<std::string>
    body: |
      return advanced_code_editor.get_lines();


  - name: get_cursor
    private: true
    type: Hexagon::AdvancedCodeEditor::Cursor
    body: |
      return advanced_code_editor.get_cursor_ref();


  - name: is_in_edit_mode
    type: bool
    body: |
      return mode == 0;


  - name: is_in_insert_mode
    type: bool
    body: |
      return mode == 1;


  - name: refresh_text_mesh
    private: true
    guards: [ initialized ]
    body: |
      char clear_char = '\0';
      ALLEGRO_COLOR clear_color = ALLEGRO_COLOR{0.0f, 0.0f, 0.0f, 0.0f};
      ALLEGRO_COLOR on_color = ALLEGRO_COLOR{1.0f, 1.0f, 1.0f, 1.0f};
      std::vector<std::string> &lines = advanced_code_editor.get_lines_ref();

      for (unsigned y=0; y<num_rows; y++)
      {
         for (unsigned x=0; x<num_columns; x++)
         {
            char char_to_set = clear_char;
            ALLEGRO_COLOR color_to_set = clear_color;

            if (y < lines.size())
            {
               if (x < lines[y].size())
               {
                  char_to_set = lines[y][x];
                  color_to_set = on_color;
               }
            }

            text_mesh.set_cell_character(x, y, char_to_set);
            text_mesh.set_cell_color(x, y, color_to_set);
         }
      }
      return;


dependencies:


  - symbol: std::map<std::string, std::function<void(Hexagon::AdvancedCodeEditor::Stage&)>>
    headers: [ map, string, functional, Hexagon/AdvancedCodeEditor/Stage.hpp ]
  - symbol: StageInterface
    headers: [ Hexagon/StageInterface.hpp ]
  - symbol: placement3d
    headers: [ allegro_flare/placement3d.h ]
  - symbol: AllegroFlare::FontBin*
    headers: [ AllegroFlare/FontBin.hpp ]
  - symbol: ALLEGRO_FONT*
    headers: [ allegro5/allegro_font.h ]
  - symbol: ALLEGRO_EVENT
    headers: [ allegro5/allegro.h ]
  - symbol: ALLEGRO_EVENT&
    headers: [ allegro5/allegro.h ]
  - symbol: ActionData
    headers: [ Hexagon/ActionData.hpp ]
  - symbol: Hexagon::AdvancedCodeEditor::AdvancedCodeEditor
    headers: [ Hexagon/AdvancedCodeEditor/AdvancedCodeEditor.hpp ]
  - symbol: Hexagon::AdvancedCodeEditor::Renderer
    headers: [ Hexagon/AdvancedCodeEditor/Renderer.hpp ]
  - symbol: KeyboardCommandMapper
    headers: [ AllegroFlare/KeyboardCommandMapper.hpp ]
  - symbol: Hexagon::Elements::TextMesh
    headers: [ Hexagon/Elements/TextMesh.hpp ]
  - symbol: Hexagon::AdvancedCodeEditor::Cursor
    headers: [ Hexagon/AdvancedCodeEditor/Cursor.hpp ]
  - symbol: Hexagon::AdvancedCodeEditor::EventController
    headers: [ Hexagon/AdvancedCodeEditor/EventController.hpp ]
