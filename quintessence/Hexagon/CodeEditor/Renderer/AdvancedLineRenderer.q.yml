properties:
  - name: font
    type: ALLEGRO_FONT*
    init_with: nullptr
    constructor_arg: true
  - name: font_color
    type: ALLEGRO_COLOR*
    init_with: nullptr
    constructor_arg: true
  - name: x
    type: float
    init_with: 0.0f
    constructor_arg: true
  - name: y
    type: float
    init_with: 0.0f
    constructor_arg: true
  - name: line
    constructor_arg: true
functions:
  - name: build_quoted_string_tokens
    type: std::vector<std::tuple<std::string, int, ALLEGRO_COLOR>>
    private: true
    body: |
      std::vector<std::tuple<std::string, int, ALLEGRO_COLOR>> tokens;

      std::string regex = "";
      {
         // this regex provided by https://stackoverflow.com/a/249937/6072362
         std::string quoted_string_regex = Hexagon::RegexStore::double_quoted_strings_with_escapes();
         regex = quoted_string_regex;
      }

      RegexMatcher regex_matcher(line, regex);

      std::vector<std::pair<int, int>> match_infos = regex_matcher.get_match_info();

      for (auto &match_info : match_infos)
      {
         ALLEGRO_COLOR quote_color = AllegroFlare::color::color(al_color_name("coral"), 0.225);
         std::string str = line.substr(match_info.first, match_info.second);
         tokens.push_back({ str, match_info.first, quote_color });
      }

      return tokens;
    body_dependency_symbols:
      - RegexMatcher
      - Hexagon::RegexStore
  - name: build_comment_tokens
    type: std::vector<std::tuple<std::string, int, ALLEGRO_COLOR>>
    private: true
    body: |
      std::vector<std::tuple<std::string, int, ALLEGRO_COLOR>> tokens;
      ALLEGRO_COLOR comment_color = AllegroFlare::color::color(al_color_name("black"), 0.5f);
         //AllegroFlare::color::color(al_color_name("black"), 0.3f)

      std::string regex = "";
      {
         //std::string comments_not_inside_quotes_regex = "([\"'])(?:\\?+.)*?\1";
         std::string basic_comment_regex = "//.*";
         regex = basic_comment_regex;
      }

      RegexMatcher regex_matcher(line, regex);

      std::vector<std::pair<int, int>> match_infos = regex_matcher.get_match_info();

      if (match_infos.empty())
      {
         //tokens = { { line, 0, *font_color } };
      }
      else if (match_infos.size() == 1)
      {
         int string_end = match_infos[0].first;
         std::string uncommented_substr = line.substr(0, string_end);
         std::string commented_substr = line.substr(string_end);
         tokens = {
            //{ uncommented_substr, 0, *font_color },
            { commented_substr, string_end, comment_color },
         };
      }
      else if (match_infos.size() > 1)
      {
         throw std::runtime_error("unexpected multi match error");
         //ALLEGRO_COLOR error_color = al_color_name("red");
         //tokens = { { line, 0, error_color } };
      }

      return tokens;
    body_dependency_symbols:
      - RegexMatcher
  - name: render_tokens
    type: void
    private: true
    parameters:
      - name: tokens
        type: std::vector<std::tuple<std::string, int, ALLEGRO_COLOR>>
        default_argument: "{}"
      - name: cell_width
        type: float
        default_argument: 1.0f
    body: |
      for (auto &token : tokens)
      {
         std::string &text = std::get<0>(token);
         int x_position = std::get<1>(token);
         ALLEGRO_COLOR color = std::get<2>(token);

         al_draw_text(font, color, x + (x_position * cell_width), y, ALLEGRO_ALIGN_LEFT, text.c_str());
      }
    body_dependency_symbols:
      - al_draw_text
      - std::get
  - name: render
    type: void
    body: |
      if (!font)
      {
         std::stringstream error_message;
         error_message << "[Hexagon/Powerbar/Renderer/AdvancedLineRenderer error:] cannot \""
                       << __FUNCTION__ << "\" with a nullptr font";
         throw std::runtime_error(error_message.str());
      }
      if (!font_color)
      {
         std::stringstream error_message;
         error_message << "[Hexagon/Powerbar/Renderer/AdvancedLineRenderer error:] cannot \""
                       << __FUNCTION__ << "\" with a nullptr font_color";
         throw std::runtime_error(error_message.str());
      }

      // draw the line straight out
      al_draw_text(font, *font_color, x, y, ALLEGRO_ALIGN_LEFT, line.c_str());

      float cell_width = al_get_text_width(font, " ");

      std::vector<std::tuple<std::string, int, ALLEGRO_COLOR>> tokens;

      //tokens = build_comment_tokens();
      //render_tokens(tokens, cell_width);

      tokens = build_quoted_string_tokens();
      render_tokens(tokens, cell_width);

      return;

    body_dependency_symbols:
      - RegexMatcher
      - al_get_text_width
      - AllegroFlare::color::color
      - std::stringstream
      - al_color_name
      - ALLEGRO_ALIGN_LEFT
      - std::vector<std::tuple<std::string, int, ALLEGRO_COLOR>>
dependencies:
  - symbol: Hexagon::RegexStore
    headers: [ Hexagon/RegexStore.hpp ]
  - symbol: al_get_text_width
    headers: [ allegro5/allegro.h ]
  - symbol: AllegroFlare::color::color
    headers: [ AllegroFlare/Color.hpp ]
  - symbol: RegexMatcher
    headers: [ Hexagon/RegexMatcher.hpp ]
  - symbol: std::get
    headers: [ utility ]
  - symbol: std::vector<std::tuple<std::string, int, ALLEGRO_COLOR>>
    headers: [ vector, tuple, string, allegro5/allegro_color.h ]
  - symbol: al_draw_text
    headers: [ allegro5/allegro.h ]
  - symbol: al_color_name
    headers: [ allegro5/allegro_color.h ]
  - symbol: ALLEGRO_ALIGN_LEFT
    headers: [ allegro5/allegro.h ]
  - symbol: ALLEGRO_FONT*
    headers: [ allegro5/allegro_font.h ]
  - symbol: ALLEGRO_COLOR*
    headers: [ allegro5/allegro.h ]
